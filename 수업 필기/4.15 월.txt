imshow를 하고 destroy로 닫아줘야되는데 중간에 opencv를 이용해서 wait해줘야한다.
cv2.imshow("frame", img)
cv2.waitKey()
cv2.destroyAllWindows()

같은 이름 "frame" 에 저장했으므로 한 frame에서 나타낸다.

img의 shape은 (12,512,3)
b = img[:, :, 0]
g = img[:, :, 1]
r = img[:, :, 2]
b,g,r각각의 shape은 (512,512)

 hsv로 변환해주고 위와같이 h,s,v로 나눠줄 수 있음
 
hsv는 255까지밖에 표현을 못해줘서 원래 색을 360까지의 값으로 표현하는데 180으로 줄임

bitwise_and 연산은 같은 위치에 있는 것끼리 비교해줌.

보고싶은 부분을 255로 해주고 나머지는 0이므로 다 까맣게 나옴

###
hsv가 우리가 하려는 일을 더 잘할수있으므로 바꿔주고
값들을 분할해서 빨간색의 영역을 찾아줌
색은 0~10이고 채도는 100~255인 애들을 찾아준다
여기에는 값들이 0과 255밖에 없음. 채도와 명도
low_red1, up_red1 사이에 있는 값들을 찾아주는 과정은 빨간색을 찾아주는 과정이다

cv2.threshold => 이진화 하는 함수. 변환방식에 따라 threashold를 기준으로 처리를 해준다. 처리 후 값은 두 가지만 남게된다

이진화 해주는 이유: 사람이 보기위한 것이 아니고 컴퓨터로 분석을 할때 여러 값들이 있으면 값을 처리하기가 힘든데 이진화를 통해 기준을 두고 값들을 극단적으로 바꾸면 구분하기가 편하다

동영상에서는 클래스를 사용한다

cv2.VideoCapture(0) => 이 코드로 카메라와 웹프로그램이랑 연결한 것.
카메라 끌때까지 하므로  while문

0을 입력받을땐 카메라 연결. 문자열을 입력받으면 동영상 연결

cv2.waitKey() == 27
여기에서 27은 이스케이프 문자를 뜻하고. esc가 눌렸는지를 말한다
그리고 이 코드는 1/1000초에 한 프레임씩 보여준다

*(20, 30)  은 가변인자를 하나씩 준다.   => 20, 30



