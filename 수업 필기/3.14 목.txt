함수 : 입력을 받아서 처리한 결과를 반환하는 사용자정의 연산자

구현 - 파라미터를 입력을 받는데 어떤것을 받을지
파라미터 - 기본값이 없는 것(필수로 줘야됨). 기본값이 있는 것(선택사항). 
	       가변인자(*args, **kwargs)

def 이름(a, b, c=0, d='abc')
 
return: 함수를 정상적으로 종료한 후에 호출한 곳을 반환값을 가지고 돌아가.
return 반환값: 한개. 여러개일때는 -> 자료구조로 묶어서 반환.

if 종료조건:
	return
이때는 return을 해줘야됨

set으로 결과를 담을 일은 거의 없다. 중복을 제거할때 뺴고는. 값이 사라지기 떄문에


함수를 설명할때
'''
docstring = 함수나 클래스에 대한 설명을 달아주는 것.
BMI 지수를 이용해서 비만 여부를 알려주는 함수.
parameter
	tall : float - 키. 단위 미터.
	weight : float - 몸무게. 단위 kg.
return 
	dict : BMI지수, 비만여부
'''

클래스로부터 인스턴스 생성.
클래스는 어떤 변수와 매소드가 있는지를 선언해둔것이고 인스턴스는 값을 넣어둔것.
사람이라는 클래스가 있으면 이름이 필요하고 나이가 필요해요 이고. 이름은 홍길동이고 나이는 20살이다가 인스턴스

Person 객체를 가질때 name, age, address는 가지고 시작하게 만드려면 initializer(객체를 초기화 시켜주는 애)가 필요하다.
이니셜라이저는 특수메소드이다. 
객체가 생성될때 무조건 호출되게 되어있다.

함수는 0개에서 여러개, 클래스의 파라미터는 1개에서 여러개
클래스안에 들어있는 매서드들은 일단 self를 선언을 하고 원하는것을 추가해야한다.
관례적으로 self를 줌.

self에는 저장공간 자체가 전달이 됨.
메소드도 함수의 종류인데 클래스안에 들어간것.
메소드 안에 들어간것도 다 로컬변수이다. 그래서 로컬변수가 저장된 공간이 있을텐데 
객체가 생성됐을때 만들어진 p가 self에 들어간다.

전역변수 p1에 값이 들어있는 박스가 들어가는것.

동작들은 메소드
인스턴스 매소드는 객체가 제공해주는 기능

메소드를 호출할때 => p.set_info(

self는 메소드가 일하는동안만 존재.

변수에 들어가는 값들을 제한하고싶을때 -> 값을 제한하는 메소드를 만들어야된다.
근데 메소드를 만들었는데 그 메소드를 안쓴다면? 그것도 문제. 메소드를 만드는것만이 아니라 p.age = -40처럼 대입하는 것도 막아줘야되는데 이것이 정보 은닉 information hiding이라고 한다.


메소드 이름이 같으면 안되는데 name으로 같다. 그래서 우리가 주석으로 알려줘야되는데 일반주석은 사람이 보는것이므로 프로그램이 알수 있는 주석을 달아준다. @붙여주기
@가 붙은 메소드는 어떻게 처리해야되는지를 알려주는 것.
만들 일은 많이 없지만 만들어진것을 써야될 일은 있으므로 어떻게 쓰는지 알기.
@property 라는것은 getter메세지라는 것이고. @getter메소드이름.setter 은 getter메소드이름과 관련된 setter메소드라는것을 알려준다.

getter setter 순서로 해야되고 일반 메소드 전에 위치해야된다.

self.name = name 코드 자체가 'name setter 함수를 부르세요'이다.

p = Person('이순신', 22, '서울')  => 여기서는 set_name 해준것
p.print_info()  => 이때는 get_name 해줌

메소드를 변수처럼 사용할 수 있게 해주는것
게터세터가 있으면 실제로 호출되는 것은 메소드.
게터세터를 통해 방법을 통일해준다.


name, age -> 메소드
__name, __age, address -> attribute

객체.name = 값 이런식으로 쓰는데 이게 실제 name이라는 변수에 값을 대입하라는게 아니라
name메소드에 값을 넣어서 ( name(값) ) 호출하라는 뜻  (setter - @name.setter 메소드를 부른것)

print(객체.name)(조회)  => name() 호출 (getter - @property 라는 메소드를 부른것)
객체: 외부 - p.name 으로 부르고 내부: self

이게 class라는 개념이 나오면서 생긴것. 원래는 전역변수와 지역변수밖에 없었는데 여기서는 값을 제한할 수가 없었다. 하지만 변수를 class라는 객체 안에 넣게되면서 객체 안과 밖이라는 구역이 나눠지게된다. 

상속 -> 클래스와 클래스간의 관계이다. 물려받는것.

메소드만 쓸수있는것처럼 보이는데 상속은 attribute와 메소드 모두 사용가능.

person과 student 속성이 따로 만들어지지만 student s 에서 person의 속성을 사용가능.
메모리에 알아서 부모에 대한 instance도 만들어줌

go라는 개념은 teacher와 student 모두 필요한 개념이므로 상위 클래스인 student에 만들어두고 teacher와 student가 상속을 받아서 사용한다.

공통된 것을 따로 추가하는것이 아니라 상위 클래스에서 한번에 추가 가능하므로 유지보수에 편리하다. 

메소드 오버라이딩은 상위 클래스에서 사용하는 메소드를 사용하지만 하위 클래스마다 조금씩 다르게 변형하는 것.
하위 클래스에서 이름은 똑같지만 기능을 다르게 정의하면서 같은 이름이지만 다른 기능을 하는 메소드를 만들 수 있다.

만약에 student에서 eat2를 만들어서 새롭게 만들면 student에서는 먹는다는 기능만 두가지가 생기게 되므로
똑같은 이름을 써서 내용만 재정의할수있게 해주었다.

자신한테 있는 메소드면 자기꺼 실행. 없으면 상위 클래스를 확인.

teacher의 객체를 받았는데 teacher.eat()은 teacher의 객체를 부른것. 근데 self.eat()은 또다시 eat을 부른것 그래서 계속 반독됨
self.go() 는 자신한테 없으니까 상위로 가서 실행시켜준건데, 오버라이팅을 하게되면 자식클래스인 자신한테도 있으므로 부모 클래스의 eat은 self.eat() 형태로 부르지 못하고 => super()라고하는 내장함수로 부른다

self 가 아니라 super() 사용
super().eat()

상위 클래스의 역할은 하위 클래스들의 공통점을 정의시켜놓는것이다.


내꺼긴 하지만 name과  age는 person한테 줘야된다. 저장할때는 따로 저장해야됨. 그래서 super().__init__을 통해 초기화해줌 => 이름과 나이는 부모 클래스에 저장해둠


student를 만들떄 student instance와 person instance를 만들어줌

! ! 명령문에 따라 어떤 과정인지 생각해보고 메모리 위치도 같이 생각해보기. 그려보면서


특수 메소드는 우리가 실행하는게 아니라 파이썬에서 알아서 호출하는것. 상황에 맞게 메소드를 실행한다.

객체를 함수처럼 써. 메소드가 하나밖에 없을때 call에다가 만들면 객체를 함수처럼 쓸 수 있게 해준다.
기능이 하나인 경우엔 대부분 call에 구현.

__str__ 에서는 보통 class가 어떤 속성들을 가지고 있는지 리턴해줌
print(p) 는 값을 string으로 변환(str()) 후 출력

문자와 숫자에서 add가 다르게 계산되는 이유는 서로 다르게 저장해놨기때문  ( 오버리딩 사용 )

== 을 구현하면 != 는 가능.

init,str,eq 은 보통 구현해줌. 나머지는 필요에 따라

add는 재정의 필요 x , 근데 eq에서 학생의 경우 grade까지 비교해주려면 재정의 해야됨.

class 변수는 객체와는 상관없이 클래스 자체에 변수를 만들고 싶을때 사용. 그리고 그 변수를 다루는게 class 메소드
static변수는 그냥 일하는애. 함수를 클래스 안에다가 정의했다.

남자와 남성은 같은말이지만 비교햇을떄는 다르다고 나온다. 그래서 class내에서 정의해놓고 선택을 할수있게 해줘야되는데 이때 필요한게 클래스 변수이다.

변수명이 대문자면 관례적으로 바꾸지말고 정해진 값을 써라.