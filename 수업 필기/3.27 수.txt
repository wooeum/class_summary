3.26 복습
파서의 종류는 여러가지가 있는데 우리는 lxml사용.

find, find_all -> 동일한게 여러개있으면 다 찾아온다.  딱 하나일때가 보장이 되면(ex. ID) find를 쓰고 나머지는 find_all사용

result.contents
result.text
.get  = 속성의 값이 무엇인지 알고싶을떄

selector 와 x path를 익히는 것이 어렵지 bs4가 어려운건 아니다.

requeset 모듈은 http를 받아올수있게 해줌

요청파라미터를 보내야된다 -> url뒤에 where은 ~ sm은 ~ 을 해야될때 직접 써줘도 되지만 
딕셔너리로 정의한 후에 전달하는게 편함

레퍼러 체크하기
----------------------------------------------
03_asyncio

비동기적인애들은 동시에 실행되므로 효율적이다.

비동기는 결국엔 하나에 하나씩 예시는cpu 사용안할떄 다른걸해서 동시에하는것처럼 보이지만 진짜로 여러개를 하는건 아님 cpu는 하나이므로

병렬은 진짜로 같이하는것. cpu가 4개있는것과 같음

이게 왜 필요한가? 비동기적인 처리를 하는데 비동기는 진짜 병렬이 아니다
동시에 두개를 못하니까 번갈아가면서하는데 서브루틴개념은 서브루틴이 끝나야 메인으로 돌아가므로 비동기와 느낌이 다르다. 그래서 코루틴 알고리즘을 사용해 서로 멈추고 실행하는 과정을 나타내겠다.

generator도 iterable타입이다.
for문으로 돌릴수있따.
리스트와 다른점은 generator는 값을 제공하는 로직을 가지고있다

코드 마지막에 return이 오면 함수. 마지막에 yield가 오면 제너레이터

실행하려면 generator 객체를 생성해야하는데 함수호출하듯이 하면 된다.

my_gen(10) 은 객체를 생성한것.


#이벤트 루프: 실행 대기실 - 실행 로직들(task) 

실행 제어권을 얻으면 올라가고 상실하면 이벤트 루프로 돌아옴
우리가 해야될건 이벤트 루프라는 실행 대기실과 task인 코루틴을 만드는 것이다. task도 함수처럼 만든다. 구문은 비슷함

await.코루틴 -> 

main이라는 코루틴을 하나 사용했는데 main코루틴은 my_sleep함수를 순차대로 실행한다. 그래서 6초가 나오는데

우리가 원하는대로 나오려면 event loop에 sleep이 들어가야된다. -> task가 되어야한다.

이벤트루프에서는 blocking이라는 상태가 바뀌는 상황마다 task를 바꿔주는 역할을 해준다.

항상 main코루틴을 만든후에 메인에서는 task들을 만들어서 이벤트 루프에 등록하는 작업을 처리한다.

requests의 역할을 비동기적으로 하는것 = aiohttp 패키지

close를 해줘야되므로 with절을 사용하는데 코루틴을 사용하는 with절이므로 async해줘야된다

requests는 요청할떄 헤더를 알아오면
이거는 한번에 가므로 한번에 알아옴