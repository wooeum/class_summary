우리가 class를 만드는 이유는 비슷한것들끼리 묶어주기 위해 생겨났다.

class로 묶긴했지만 class외부에서 접근을 못하게하는것이 아니다.
class 규칙에 맞는 값이면 바꿔준다.  => __를 통해서 조건에 안맞는 값들을 막아주고 메소드를 통해 값들을 받아줘서 적절히 처리한다.  => 정보은닉. 목적이 이것

왜 클래스를 만들어야되는지? 
클래스라는 데이터 타입을 만든 것이다. 그리고 클래스를 처리하는 함수들을 그 안에 넣자

오버라이딩 -> 똑같은 메소드를 내용만 다르게 한다.

-------------------------------------------- 
07_패키지_모듈

import는 패키지나 모듈을 쓰겠다.

재사용가능한 파일을 넣어둔 것  = 모듈
스크립트에서 여기서 가져다 쓰려고 외부에 뺴놓는것.

파일이 너무 많아서 모듈을 여러개에 나눠서 넣어줬다
만약에 모듈을 a라는 

모듈 : 파일 -> 재사용가능한 기능(함수, 클래스, 변수) 들을 정의한 파이썬 파일  ( ~ .py)
패키지 : 디렉토리 (폴더) -> 모듈을 담고있는 디렉토리


모듈은 저장해두는것이 목적이다.

모듈을 import하면 모듈공간을 만들어주는데
from 모듈 import 함수를 하면 함수를 지금 모듈로 가져오는것이다 => 그래서 module.함수명 이렇게 안쓰고 그냥 함수명으로 사용가능하다

원래 greet()이라는 함수가 있는데 import해서 greet() 함수를 가져오게되면 동일한 이름은 덮어씌우므로 전에 있던 함수를 사용하지 못함. 그러므로 함수가 아닌 모듈을 가져와야된다

from my_module import * -> 이걸통해 모든 함수를 다 가져올 수 있지만 추천하지 않는다. 보통 함수의 개수가 너무 많아서 충돌날 수 있음

파이썬 실행환경한테 import할 라이브러리 위치를 알려줘야된다. 실행할때마다 해줘야됨. 계속 넣어두려면 환경변수에 넣어둬야됨

변수이름 : PYTHONPATH
변수 값 : C:\temp

모든 모듈은 다 import해서 사용해야됨

가상환경을 만들었을떄마다 거기에서 주피터랩을 설치해야된다.

pip install -r requirements.txt
아까 freeze > requirements.txt로 저장한 파일을 위에 방법을 통해 동일한 버전의 환경을 다시 만들 수 있다.
-----------------------------------------------------------

08_예외처리

0으로 숫자를 나눴을때 나는 오류 : division by zero

except 발생 가능성이 있는 줄만 감싸는게 아니라 관련된 코드를 다같이 묶어줘야된다.
<ex>
try:
	i = 10 / 0
	j = i * 3
	print(j)
except:


class WrongDateException(Exception):
    pass
=> 이정도만 해도 가능. 예외 이유를 구체화 시킬때는 여기까지만.

이왕이면 exception과 관

raise는 exception을 발생시키는 코드이다.
어떤 익셉션이 났는지를 익셉션 객체를 통해서 보내주는 것이다.
raise(e)와 같이.
왜 객체로 만들었는가? 익셉션이 난 이유에 대한 정보를 알려줘야되기때문에.

익셉션을 상속받아야 raise할 수 있다.

1.Exception 이란
2.Exception 처리(handling)
3.발생한 Exception(에러)을 처리해서 프로그램 실행을 정상화.

Exception 클래스 구현
Exception 발생 - 왜 못하는지 말해줌. 그리고 실행도 끝내줘야됨 , 발생방법 - raise. raise와 return의 차이

----------------------------------------------
09_입출력

연결할 기능을 가지고있는것을 리턴해줌. 

