4.4 컴프리헨션 
[v for v in l] 여기에서 맨 앞에 v가 의미하는건 append와 같다
[v*2 for v in l] 이거는 v값을 두배해서 넣어준다는 뜻
리스트에 담겼으므로 리스트 컴프리헨션 => 어디에 담긴지에 따라 컴프리헨션 종류가 달라짐

{ i:v for i, v in enumerate(l) }  => 딕셔너리 컴프리헨션
(    ) 튜플로 하려는데 generator가 나옴

-----------------------------------------------------------
05_함수

함수를 값처럼 변수에 넣어서 사용할 수 있는 언어가 있고 없는 언어가 있는데 파이썬은 가능하다

return => 함수 실행을 (정상적) 종료하고 호출한 곳으로 돌아가라.

기본값이 있는 파라미터
예시     def greet(name=None):
               ~~~

이때 순서가 있는데 기본값이 없는 매개변수를 먼저 선언하고 그후에 기본값이 있는 매개변수를 선언한다

이 두개는 함수를 호출할때 사용하는 것들
argument를 파라미터 순서에 맞춰서 전달하는 것이 positional argument라고 한다 => 이0것이 일반적
keyword argument에서는 argument와 파라미터의 순서가 안맞아도 상관없음



가변인자는 두종류

# 정수 값들을 받아서 합계를 반환.
# *변수명 - *arg : positional arguments 로 개수와 상관없이 값들을 전달받을때 사용.
#                 내부적으로는 tuple 처리

<ex>
def summation(*nums):
    result = 0
    for v in nums:
        result += v
    return result


summation(1, 2, 3, 4, 5)

이때 인자가 nums라면 함수에 arguments가 리스트같은 형태로 나와야한다. 여러개를 넣어주려면
하지만 *nums로 한다면 개수가 더 많더라도 튜플로 전달을 해주기때문에 상관없다.
여기에서 *nums를 튜플로 생각해도 된다.

** 는 키워드 아규먼트 => 얘는 호출하는 아규먼트의 개수와 상관없이 값들을 받을때 사용
				    값들을 딕셔너리로 묶어서 전달받는다.

*args가 막 좋은건 아니다. 호출하는 사람이 뭐를 넣어야될지 모를떄가 있다. 값이 여러개가 가능하므로 몇개를 넣어야되고 보통 이름이 arg이므로 뭐하는 애인지 몰라서 설명이 제대로 되어있지않다면 사용하기 불편하다.
만들떄는 편함.  안받지만 호환성을 위해 넣을때도 있음


# 가변인자에 리스트나 튜플의 원소들을 전달 => *리스트, *튜플
# 가변인자에 리스트나 튜플에 있는 값들을 하나하나 전달해주고싶을때
l = [1, 2, 3, 4, 5]
summation(*l)

**가변인자에 딕셔너리의 값들을 전달하는 경우: **딕셔너리


변수가 있을떄 변수를 어디서부터 어디까지 호출할 수 있는가
그러기위해선 변수의 종류를 알아야한다


변수는 메모리(RAM)에 저장되는데 메모리에서의 위치가 다르다


f = hello()   => hello 함수를 호출해서 실행. 반환값을 변수 f에 저장
f = hello     => hello 함수 자체를 f변수에 대입. (다른 이름을 준다.)

sorted에서.
sorted로 정렬을 하면 값을 기준으로 정렬을 하는데 다른기준으로 정렬하고싶으면 함수로 알려줘라는 뜻
#함수를 넘겨주는 개념이 이렇게 쓰임 , 만들어주는 함수는 쓰임에 맞게 만들어야됨

람다는 최소한 파라미터가 하나있을때 만듬

객체지향 = 나눠서 개발하자. 나눌때는 서로 관련있는 것끼리.

고객 
나이:30   => 나이는 속성이다. instance는 각각의 값을 의미한다.여기서는 30.

클래스를 만들었는데 변수1, 변수2, 함수가 같이있다면 보통 함수들이 변수1, 변수2를 다룬다. 다른 값들을 다루는 경우는 적다.
클래스 안에 정의한 함수를 메소드라고 하는데 이름을 다르게 줘야 일반 함수와 구분이 되기 때문이다.
ex) upper() 라는 함수는 문자열만 다루므로 문자열 클래스에 넣는다.
ex) len() 함수는 iterable한 값들은 다 가능하다. 리스트,튜플, 딕셔너리, 문자열,숫자 ...등 다양하게 필요하므로 그냥 함수로 만들어버린것이다. 
특정 타입과 관련된 것들은 메소드로 만들기.

//////////////////////////////////
Class에는 다음 두가지를 정의한다.
Attribute/State
객체의 속성, 상태 값을 저장할 변수
보통 class로 정의하는 data는 여러개의 값들로 구성된다. 이 값들을 저장하는 변수를 attribute/state 라고 한다.
고객: 고객ID, 패스워드, 이름, email, 주소, 전화번호, point ...
제품: 제품번호, 이름, 제조사, 가격, 재고량
Instance 변수라고 한다.
개별 객체는 각각의 instance변수를 가진다.
behavior
객체의 state 값을 처리하는 함수.
instance method 라고 한다.
개별 객체(instance)들은 동일한 instance 메소드를 이용해 자신의 instance 변수의 값들을 처리한다.

이 부분 다시 이해해보기
//////////////////////////////////////

클래스에서 우리는 변수와 함수를 구현해야 한다. attribute, behavior / instance변수, instance method   => 둘중 하나가 없으면 attribute가 없다라고도 함.


클래스로부터 만들어진 객체를 인스턴스라고 한다
프로그램상에서 쓸려고 만드는 객체는 인스턴스라고 얘기한다.  오브젝트와 인스턴스 둘다 객체라고 하는데 의미가 조금 다름 !!! 뭐가 다른지 정리해두기

이름은 파스칼표기법으로

실제 사용은 인스턴스를 쓰는 것이다.

처음에 우리가 어떤값을 만들꺼야 할떄는 initializer가 맞고 나중에 수정할떈 2,3번쨰. 주로 변경할때 사용한다. 새로운값을 넣을때도 가능하지만 좋은 방법은 아니다

heap이라는 공간이 생긴다. heap이라는 공간안에 name을 찾는것.heap은 메모리에 있나(?)
p.name = '이순신'  => 이 명령은 p라는 공간안에 name이라는 변수를 찾아 이순신 넣으려는데 name이 없으므로 name을 만들고 이순신을 넣어줌

이 공간을 왜 만드냐?? 다음에 p2를 만들면 메모리 공간에 Person의 내용을 저장하는 p2가 생김.
p와 p2는 다른 인스턴스가 되는것. 각자의 노트북이 다른데 노트북이 인스턴스가 된다. 각자의 정보가 다르므로 같은 값을 가질수는 있다.

처음에 초기화할때는 왜 안좋냐. 둘다 같은 클래스에 있는 사람인데 넣어주는 속성값이 다르다는것은 말이 안된다.
그러므로 이 방법은 좋지 않다. 같은 타입에서 만들어진 객체들이 다른값을 가질수도 있다는 단점이 잇다.

그래서 이니셜라이저라는 매소드로 하는것이 맞다. (self__ init__인듯?)

